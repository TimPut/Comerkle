-- |
-- Copyright: (c) 2020 tim put
-- SPDX-License-Identifier: NONE
-- Maintainer: tim put <timput@gmail.com>
--
-- Initial implementation of corecursive Merkle trees.
module Comerkle
  ( merkle
  , zerkle
  , comerkle
  , comerkleTree
  , comerkleTreeWith
  , comerkleM
  ) where

import           Control.Comonad
import           Control.Comonad.Cofree
import           Data.Bits              (Bits (..), xor)
import           Data.Hashable
import           Data.Tree

-- In a Merkle tree, each node is labelled with a hash of the subtree
-- rooted at that node. This enables O(1) equality comparisons of
-- subtrees.
merkle :: Hashable a => Tree a -> Tree Int
merkle (Node x xs) = Node x' xs'
  where
    x' = hashWithSalt salt x
    salt = foldr xor zeroBits (rootLabel <$> xs')
    xs' = merkle <$> xs

-- In a Zerkle tree, each node is labelled with a hash of the path
-- back to the root from that node. This enables O(1) equality
-- comparisons of the location of nodes in different views of a tree.
zerkle :: Hashable a => Tree a -> Tree Int
zerkle = go zeroBits
  where
    go salt (Node x xs) = Node newSalt (go newSalt <$> xs)
      where
        newSalt = hashWithSalt salt x

_zipTree :: Data.Bits.Bits t => t -> Tree t -> Tree t
_zipTree parent (Node a as) = Node a' (_zipTree a' <$> as)
  where
    a' = a `xor` parent

_limitedMerkle :: Hashable a => Int -> Tree a -> Tree Int
_limitedMerkle n (Node x xs) = if n /= 0 then Node x' xs' else Node (hash x) []
  where
    x' = hashWithSalt salt x
    salt = foldr xor zeroBits (rootLabel <$> xs')
    xs' = _limitedMerkle (n-1) <$> xs

comerkleTree :: (Monoid a) => Tree a -> Tree [a]
comerkleTree (Node a as) = Node ha has
    where
      ha = a : fmap (mappend a) children
      children = foldl (zipWith mappend) (repeat mempty) (fmap rootLabel has)
      has = fmap comerkleTree as

comerkleTreeWith :: (b -> b -> b) -> b -> Tree b -> Tree [b]
comerkleTreeWith f e (Node root subs) = Node hroot hsubs
    where
      hroot = root : fmap (f root) children
      children = foldl (zipWith f) (repeat e) (fmap rootLabel hsubs)
      hsubs = fmap (comerkleTreeWith f e) subs

-- | This function takes a comonad (context of values with a focused
-- value) and a combing function defined on those values; and
-- generates a (co-)free structure of increasingly broad local
-- summaries generated by folding the local context down to a single
-- summary value with the given combining function.
comerkle :: (ComonadCofree f w, Foldable f)
             => (b -> b -> b) -- ^ Combining function
             -> w b -- ^ Comonad of context
             -> Cofree f [b] -- ^ Cofree comonad of local contexts
comerkle f xy = x' :< y'
  where
    -- extract the local point
    x = extract xy
    -- unwrap the context
    y = unwrap xy
    -- recursively transform the original sub-contexts
    y' = fmap (comerkle f) y
    -- build stream of summaries
    children = foldl (zipWith f) (repeat x) (fmap extract y')
    -- include zero-depth context
    x' = x : children

-- | Build a a generalized comerkle comonad over a monoid.
-- Should hold that:
-- > comerkleM == comerkle (<>)
comerkleM :: (ComonadCofree f w, Foldable f, Monoid c) => w c -> Cofree f [c]
comerkleM xy = x' :< y'
  where
    -- extract the local point
    x = extract xy
    -- unwrap the context
    y = unwrap xy
    -- transform the original context to a context of summaries
    y' = fmap comerkleM y
    -- build stream of summaries
    children = foldl (zipWith mappend) (repeat mempty) (fmap extract y')
    -- annotate stream of summaries with trace of location
    x' = x : fmap (mappend x) children
